var documenterSearchIndex = {"docs":
[{"location":"lang/#Autumn-Language-2","page":"Language","title":"Autumn Language 2","text":"","category":"section"},{"location":"lang/","page":"Language","title":"Language","text":"Autumn is a programming language for modeling phenomena which exhibit more or more of the following properties:","category":"page"},{"location":"lang/","page":"Language","title":"Language","text":"Dynamics — varies as a function of time\nReactivity — varies in response to external changes\nStatefulness — retains state / memory\nStructure — has continuous and discrete data structures\nNon-determinism — state evolves probabilistically","category":"page"},{"location":"lang/#Standard-Features","page":"Language","title":"Standard Features","text":"","category":"section"},{"location":"lang/","page":"Language","title":"Language","text":"Autumn is a functional language; many of its constructs are standard. x = val  defines the symbol x to be the value val. The expression let x = var in expr defines the value x for use in another expression.   f arg1 arg2 ... = expr defines a function f with arguments and body expr.","category":"page"},{"location":"lang/","page":"Language","title":"Language","text":"-- Bind the name `x` to the value `3`\nx = 3\n\n-- Define a function with name `f` which increments its input\nf x = x + 1\n\n-- Apply f to x to yield value, bind to name `y`\ny = f x\n\nz = let\n    -- Defines local variable `a = f(x)`\n    a = f x\n  in\n    -- Apply anonymous function to value `a`\n    (\\v -> v * 2) a","category":"page"},{"location":"lang/#Types-and-Traits","page":"Language","title":"Types and Traits","text":"","category":"section"},{"location":"lang/","page":"Language","title":"Language","text":"Autumn has four concepts: values, types, traits, and representations.","category":"page"},{"location":"lang/","page":"Language","title":"Language","text":"A value is.  For instance, the symbol 1 is a value.  Functions can be defined directly on values, without the use of any variables at all.","category":"page"},{"location":"lang/","page":"Language","title":"Language","text":"-- lastname is a function which maps the input zenna to the output tavares\nlastname :zenna = tavares\nlastname :ria = das","category":"page"},{"location":"lang/","page":"Language","title":"Language","text":"Type","category":"page"},{"location":"lang/","page":"Language","title":"Language","text":"A type is a set of values","category":"page"},{"location":"lang/","page":"Language","title":"Language","text":"-- Bool is the either True or False\nBool = True | False\nBool = {True, False}\n\n-- We can represent an Integer as the set of numbers 0 to 9\nInt = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9\n\n1 + 1 = 2\n","category":"page"},{"location":"lang/","page":"Language","title":"Language","text":"Representation","category":"page"},{"location":"lang/","page":"Language","title":"Language","text":"Often we can use one kind of thing to represent many other kinds of thing.","category":"page"},{"location":"lang/","page":"Language","title":"Language","text":"-- Height can be represented as an Integer\nHeight as Int\n\n-- Distance can also be represented as an Integer\nDistance as Int\n\n-- We can use a pair of numbers to represent a Point\nPoint as x:Int y:Int\n\n-- We can represent a Ray as having an origin and a direction \nRay as orig:Point dir:Point\n\n-- Functions\np:Point = p.x + p.y","category":"page"},{"location":"lang/","page":"Language","title":"Language","text":"Traits","category":"page"},{"location":"lang/","page":"Language","title":"Language","text":"A trait is a property that values can have.  Values can have traits.","category":"page"},{"location":"lang/","page":"Language","title":"Language","text":"-- Jack has the property of being Doable\nJack is Doable\n\n-- So does Jill\nJill is Doable","category":"page"},{"location":"lang/","page":"Language","title":"Language","text":"The purpose of a trait is that you can add behaviours on ","category":"page"},{"location":"lang/","page":"Language","title":"Language","text":"f x:Doable y:Doable = x + y","category":"page"},{"location":"lang/","page":"Language","title":"Language","text":"We can add traits to more than one value at a time by adding traits to a type","category":"page"},{"location":"lang/","page":"Language","title":"Language","text":"Family = Jack | Jill\n\n-- ∀ x in Family, Doable x \nFamily is Doable","category":"page"},{"location":"lang/","page":"Language","title":"Language","text":"Functions can be defined with respect to traits","category":"page"},{"location":"lang/","page":"Language","title":"Language","text":"-- Lists are Iterable\nList is Indexable\n\nf x:Indexable = x[1]","category":"page"},{"location":"lang/#External-Variables","page":"Language","title":"External Variables","text":"","category":"section"},{"location":"lang/","page":"Language","title":"Language","text":"Autumn supports external variables.  The values of external variables are not defined within the program itself but come externally as inputs from the outside.   External variables can be used to capture user inputs, or random inputs.","category":"page"},{"location":"lang/","page":"Language","title":"Language","text":"-- A position is represented as an Int\nPos as x:Pos y:Pos\n\n-- A click is represented as a Position\nClick as Pos\n\n-- An external input\nexternal click : Click","category":"page"},{"location":"lang/#Events","page":"Language","title":"Events","text":"","category":"section"},{"location":"lang/","page":"Language","title":"Language","text":"System dynamics are modeled using the on construct on event change .  For example, in the following program, the value of x is 0 until the mouse is clicked, at which point it becomes 3:","category":"page"},{"location":"lang/","page":"Language","title":"Language","text":"x = 0\non click\n   x => 3","category":"page"},{"location":"lang/","page":"Language","title":"Language","text":"More generally, on usage follows the structure:","category":"page"},{"location":"lang/","page":"Language","title":"Language","text":"on some_event_occured\n   some_change_occurs","category":"page"},{"location":"lang/","page":"Language","title":"Language","text":"Any Boolean value is permissible as an event as the first argument of on.  ***[Is it just a Boolean value or a change in a Boolean value?].***  These may be primitive external events, such as mouse clicking, as well as events that are computed internally within the model.","category":"page"},{"location":"lang/","page":"Language","title":"Language","text":"x : Int\nx = 0\n\n-- On click, x is incremented\non click\n  x => x + 1\n\n-- When x becomes 10, it is reset to 0\non x == 10\n  x = 0\n\nx2 = {x | y = 3}\n","category":"page"},{"location":"lang/","page":"Language","title":"Language","text":"The second argument to on is some change that occurs in response to an event occurring.  ***[What kind of thing is this formally? seems like an intervention]***","category":"page"},{"location":"lang/","page":"Language","title":"Language","text":"Autumn allows you to refer to previous values of a variable using the construct prev.  For example, in the following program, x is initialized at 0, then increases at each tick ***[can we make x increment without tick?]***","category":"page"},{"location":"lang/","page":"Language","title":"Language","text":"x = 0\non tick\n  x => (prev x) + 1","category":"page"},{"location":"lang/#Quantification","page":"Language","title":"Quantification","text":"","category":"section"},{"location":"lang/","page":"Language","title":"Language","text":"It's often useful to be able to describe events that occur.","category":"page"},{"location":"lang/","page":"Language","title":"Language","text":"Autumn includes a universal quantifier forall.","category":"page"},{"location":"lang/","page":"Language","title":"Language","text":"forall x in someTrait\n  on changed x\n     x => prev x","category":"page"},{"location":"lang/","page":"Language","title":"Language","text":"We can describe events that ","category":"page"},{"location":"lang/","page":"Language","title":"Language","text":"forall x in =\n","category":"page"},{"location":"lang/#Probability","page":"Language","title":"Probability","text":"","category":"section"},{"location":"lang/","page":"Language","title":"Language","text":"Autumn programs may be probabilistic.  Autumn programs use the ~ to draw samples from random variables.","category":"page"},{"location":"lang/","page":"Language","title":"Language","text":"x = ~ uniformChoice 0 1","category":"page"},{"location":"lang/","page":"Language","title":"Language","text":"Probabilistic Autumn programs are actually simply functions from an external random input omega that is automatically included.","category":"page"},{"location":"lang/","page":"Language","title":"Language","text":"external ω : Ω\n--\nx = (uniformChoice 0 1) ω","category":"page"},{"location":"lang/#Objects","page":"Language","title":"Objects","text":"","category":"section"},{"location":"lang/","page":"Language","title":"Language","text":"Autumn programs often contain objects.  Objects have a physical location and potentially latent state.  These may be models of physical objects.","category":"page"},{"location":"lang/","page":"Language","title":"Language","text":"Object Ant","category":"page"},{"location":"lang/","page":"Language","title":"Language","text":"Different objects have different int","category":"page"},{"location":"lang/","page":"Language","title":"Language","text":"x = (Ant Position 1, 1) (Ant Position 1 1)","category":"page"},{"location":"lang/#Agents","page":"Language","title":"Agents","text":"","category":"section"},{"location":"#Autumn.jl","page":"Home","title":"Autumn.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"  ","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"tutorial/#Autumn-Program-Writing-Tutorial","page":"Tutorial","title":"Autumn Program Writing Tutorial","text":"","category":"section"},{"location":"tutorial/#Autumn-Language","page":"Tutorial","title":"Autumn Language","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Some important built-in types:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Position: arguments are x and y integer coordinates (e.g. (Position 0 0), (Position 1 1), etc.)\nCell: arguments are position of type Position and color of type String (only certain string colors will actually work), but multiple Cell constructors exist, so that the following are both valid constructions of a Cell type:\n(Cell (Position 0 0) \"blue\")\n(Cell 0 0 \"blue\") ← this constructor takes the deconstructed x and y coordinates as input rather than a Position type\nNote: An opacity argument also exists, but isn't currently handled by the interface — this should be fixed (default opacity for all colors/cells is 0.8).\nNote: Cells correspond to the squares of the grid (each has a position and a color)","category":"page"},{"location":"tutorial/#Deconstructing-an-Autumn-Program","page":"Tutorial","title":"Deconstructing an Autumn Program","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Sample Program: particles.sx","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(program\n  (= GRID_SIZE 16)\n  \n  (object Particle (Cell 0 0 \"blue\"))\n\n  (: particles (List Particle))\n  (= particles \n     (initnext (list) (updateObj (prev particles) (--> obj (Particle (uniformChoice (adjPositions (.. obj origin))))))))\t\n  \n  (on clicked (= particles (addObj (prev particles) (Particle (Position (.. click x) (.. click y))))))\n)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Every Autumn program can be divided into four parts:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Object Type Definitions\nObject Instance Definitions\nEvents (On Clauses)\nNon-Object Variable Definitions/Constants","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"1. Object Type Definitions:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"/* ... */\n(object Particle (Cell 0 0 \"blue\"))\n/* ... */","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Autumn models are all defined in terms of objects, which have the following definition syntax:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(object [objectName] [0 or more*custom field* definitions] [render]).","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In the particles example, the Particle object has no custom fields.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Autumn object definitions compile down to structs in Julia with a few default fields:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"id: used to internally track objects (i.e. within Julia)\norigin: specifies where on the grid the object should be rendered\nalive: specifies whether the Autumn rendering function should render this object\nrender: specifies the shape of the object, as a list of Cell structs relative to the origin position (0, 0)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"as well as some potentially custom fields (will be explained shortly). Only the origin, alive, and render fields are exposed to the user, while the id field is only used internally. (Technically, the current working implementation allows a user to access the id, but this will be fixed.) In addition to the object struct, the compiler also generates a constructor for the object type with the same name as the object, that takes as arguments any custom field values and the origin value. In the particles example, this constructor (in Julia) has the following signature:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"function Particle(origin::Position). ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The type of the render property is a list of cells, but unicellular objects like Particle can also be specified without the list syntax, i.e.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(object Particle (list (Cell 0 0 \"blue\"))) and","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(object Particle (Cell 0 0 \"blue\")) ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"are equivalent (the compiler turns the latter into the former).","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Custom fields:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Custom fields can be specified as follows:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(object ModifiedParticle (: [fieldName1] [fieldType1] ) (: [fieldName2] [fieldType2] ) (Cell 0 0 \"blue\")),","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"i.e. with type declarations of the custom fields between the object type name and the render value. Some concrete examples are below:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(object Light (: on Bool) (Cell 0 0 (if on then \"yellow\" else \"black\")))","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(object Snake (: head Cell) (: tail (List Cell)) (: direction Position) (list head tail))","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(object Magnet (: isAttached Bool) (list (Cell 0 0 \"red\") (Cell 0 1 \"blue\")))","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Note that the custom fields can be used as part of the render value, and that if the render value is a nested list of cells (e.g. (list head tail)), then it is automatically flattened by the compiler, so it behaves as usual.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"2. Object Instance Definitions:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"/* ... */\n(: particles (List Particle))\n(= particles \n   (initnext (list) (updateObj (prev particles) (--> obj (Particle (uniformChoice (adjPositions (.. obj origin))))))))\t\n/* ... */","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Objects can be introduced into the scene in two forms: (1) as part of a list of objects and (2) as a single, self-contained object variable. To introduce an object, you must declare its type, and use initnext to define its initial value and subsequent behavior on clock ticks. No other code (e.g. an add to scene call) is necessary; Autumn treats all objects defined in the program as inherently in the scene.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"A list of objects definition is in particles.sx. An example of a non-list object instance definition (i.e. different from the particles example) is below:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(: particle Particle)\n(= particle (initnext (Particle (Position 5 5)) (prev particle)))","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Importantly, without an object type declaration, the compiler will not recognize an object variable as an object, so it will be handled incorrectly. In other words, writing just the second line above will not work properly.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"3. Events (On Clauses):","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"/* ... */\n(on clicked (= particles (addObj (prev particles) (Particle (Position (.. click x) (.. click y))))))","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The form of an event is","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(on [boolean clause] [update assignment(s)]).","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"There are a few useful keywords that serve as shorthands for boolean clauses in the on context:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"clicked ← indicates that the grid was clicked (at any position)\nleft/ right / up / down ← indicates whether respective arrow key was pressed","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In addition, the following boolean functions (signatures given in Julia) are also common:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"clicked(position::Position) - clicked a particular position\nclicked(obj::Object) - clicked a particular object\nclicked(objs::Array{Object}) - clicked at least one object out of a list of objects","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Note also that (.. click x) and (.. click y) can be used to access a click's coordinates in an update assignment that follows a boolean clause related to clicked.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The update assignment is either a re-assignment of the value of an existing object variable, or a series of such re-assignments, wrapped in a let clause. Some examples are below:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(= particles (addObj (prev particles) (Particle (Position (.. click x) (.. click y)))))\n(on (clicked clearButton) (let ((= vessels (list)) (= plugs (list)) (= water (list))))) (from Water Plug in logic.toys)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"4. Non-Object Variable Definitions/Constants:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(= GRID_SIZE 16)\n/* ... */","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"All Autumn programs must specify an integer GRID_SIZE, and can also specify an optional background color (background must currently be a String constant, but can be extended to support varying values). Other non-object variables (e.g. relating to the state of the program) may also be defined, though the particles example doesn't have any of these state variables.","category":"page"},{"location":"tutorial/#Some-Useful-Library-Functions","page":"Tutorial","title":"Some Useful Library Functions","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"updateObj(obj::Object, field::String, value)\nupdateObj(objs::Array{Object}, updatefunc)\naddObj(objs::Array{Object}, obj::Object)\nremoveObj(objs::Array{Object}, filterfunc)\nremoveObj(objs::Array{Object}, obj::Object)\nremoveObj(obj::Object) - this sets the object's alive property to false (using the first updateObj function can reset it to true, if desired)","category":"page"},{"location":"tutorial/#Library-Reference","page":"Tutorial","title":"Library Reference","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"https://github.com/riadas/autumnal/blob/master/app/resources/autumnmodels/AutumnModelsController.jl#L651","category":"page"}]
}
